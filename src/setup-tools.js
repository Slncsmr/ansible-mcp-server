// Interactive setup tools for MCP
// Allows Claude to configure the environment by asking the user for details

import { z } from 'zod';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);
const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Schema for configuration requests
const ConfigureProxmoxSchema = z.object({
  host: z.string().describe('Proxmox host IP or hostname'),
  user: z.string().default('root@pam').describe('Proxmox username'),
  password: z.string().optional().describe('Proxmox password (optional if using API token)'),
  apiTokenId: z.string().optional().describe('API token ID (alternative to password)'),
  apiTokenSecret: z.string().optional().describe('API token secret'),
  node: z.string().default('proxmox').describe('Proxmox node name'),
  verifySsl: z.boolean().default(false).describe('Verify SSL certificates')
});

const ConfigureNetworkSchema = z.object({
  gateway: z.string().describe('Default gateway IP'),
  nameserver: z.string().default('8.8.8.8').describe('DNS server'),
  networkCidr: z.string().default('24').describe('Network CIDR prefix'),
  domain: z.string().optional().describe('Domain name for services')
});

const ConfigureServicesSchema = z.object({
  nextcloudIp: z.string().optional().describe('IP for Nextcloud VM'),
  mailserverIp: z.string().optional().describe('IP for Mail server VM'),
  keycloakIp: z.string().optional().describe('IP for Keycloak SSO VM'),
  nginxIp: z.string().optional().describe('IP for Nginx Proxy Manager VM')
});

const GetConfigSchema = z.object({
  section: z.enum(['all', 'proxmox', 'network', 'services', 'status']).default('all')
});

const TestConnectionSchema = z.object({
  service: z.enum(['proxmox', 'ssh', 'ansible']).describe('Service to test')
});

// Helper to read current config
async function readConfig() {
  const envPath = path.join(__dirname, '..', '.env');
  try {
    const content = await fs.readFile(envPath, 'utf-8');
    const config = {};
    
    content.split('\n').forEach(line => {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, ...valueParts] = trimmed.split('=');
        config[key] = valueParts.join('=');
      }
    });
    
    return config;
  } catch (error) {
    return {};
  }
}

// Helper to write config
async function writeConfig(updates) {
  const envPath = path.join(__dirname, '..', '.env');
  const envExamplePath = path.join(__dirname, '..', '.env.example');
  
  // Read existing config
  const current = await readConfig();
  const merged = { ...current, ...updates };
  
  // Read .env.example to get structure and comments
  let template = '';
  try {
    template = await fs.readFile(envExamplePath, 'utf-8');
  } catch {
    // If no example, create basic structure
    template = `# MCP Server Configuration
# Generated by interactive setup

# Proxmox Configuration
PROXMOX_HOST=
PROXMOX_USER=
PROXMOX_PASSWORD=

# Network Configuration
DEFAULT_GATEWAY=
DEFAULT_NAMESERVER=
`;
  }
  
  // Update values in template
  let result = template;
  Object.entries(merged).forEach(([key, value]) => {
    const regex = new RegExp(`^${key}=.*$`, 'gm');
    if (regex.test(result)) {
      result = result.replace(regex, `${key}=${value}`);
    } else {
      // Add to end if not in template
      result += `\n${key}=${value}`;
    }
  });
  
  await fs.writeFile(envPath, result);
  
  // Reload environment in current process
  process.env = { ...process.env, ...merged };
}

// Setup tools
export const setupTools = [
  {
    name: 'setup-proxmox',
    description: 'Configure Proxmox connection settings',
    inputSchema: ConfigureProxmoxSchema,
    handler: async (args) => {
      try {
        const updates = {};
        
        // Basic settings
        updates.PROXMOX_HOST = args.host;
        updates.PROXMOX_USER = args.user;
        updates.PROXMOX_NODE = args.node;
        updates.PROXMOX_VERIFY_SSL = args.verifySsl.toString();
        
        // API URL
        updates.PROXMOX_API_URL = `https://${args.host}:8006/api2/json`;
        
        // Authentication - either password or API token
        if (args.apiTokenId && args.apiTokenSecret) {
          updates.PROXMOX_API_TOKEN_ID = args.apiTokenId;
          updates.PROXMOX_API_TOKEN_SECRET = args.apiTokenSecret;
          // Clear password if using token
          updates.PROXMOX_PASSWORD = '';
        } else if (args.password) {
          updates.PROXMOX_PASSWORD = args.password;
          // Clear token if using password
          updates.PROXMOX_API_TOKEN_ID = '';
          updates.PROXMOX_API_TOKEN_SECRET = '';
        }
        
        await writeConfig(updates);
        
        return {
          success: true,
          output: `Proxmox configuration updated:
- Host: ${args.host}
- User: ${args.user}
- Node: ${args.node}
- Auth: ${args.apiTokenId ? 'API Token' : 'Password'}
- SSL Verification: ${args.verifySsl ? 'Enabled' : 'Disabled'}

Configuration saved to .env file.`
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to configure Proxmox: ${error.message}`
        };
      }
    }
  },
  
  {
    name: 'setup-network',
    description: 'Configure network settings for VMs',
    inputSchema: ConfigureNetworkSchema,
    handler: async (args) => {
      try {
        const updates = {
          DEFAULT_GATEWAY: args.gateway,
          DEFAULT_NAMESERVER: args.nameserver,
          DEFAULT_NETWORK_CIDR: args.networkCidr
        };
        
        if (args.domain) {
          updates.DEFAULT_DOMAIN = args.domain;
        }
        
        await writeConfig(updates);
        
        return {
          success: true,
          output: `Network configuration updated:
- Gateway: ${args.gateway}
- DNS Server: ${args.nameserver}
- Network CIDR: /${args.networkCidr}
${args.domain ? `- Domain: ${args.domain}` : ''}

Configuration saved to .env file.`
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to configure network: ${error.message}`
        };
      }
    }
  },
  
  {
    name: 'setup-services',
    description: 'Configure IP addresses for services',
    inputSchema: ConfigureServicesSchema,
    handler: async (args) => {
      try {
        const updates = {};
        
        if (args.nextcloudIp) {
          updates.NEXTCLOUD_IP = args.nextcloudIp;
        }
        if (args.mailserverIp) {
          updates.MAILSERVER_IP = args.mailserverIp;
        }
        if (args.keycloakIp) {
          updates.KEYCLOAK_IP = args.keycloakIp;
        }
        if (args.nginxIp) {
          updates.NGINX_IP = args.nginxIp;
        }
        
        await writeConfig(updates);
        
        const configured = Object.entries(updates)
          .map(([key, value]) => `- ${key.replace(/_IP$/, '')}: ${value}`)
          .join('\n');
        
        return {
          success: true,
          output: `Service IPs configured:
${configured}

Configuration saved to .env file.`
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to configure services: ${error.message}`
        };
      }
    }
  },
  
  {
    name: 'get-config',
    description: 'Get current configuration values',
    inputSchema: GetConfigSchema,
    handler: async (args) => {
      try {
        const config = await readConfig();
        let output = '';
        
        const sections = {
          proxmox: ['PROXMOX_HOST', 'PROXMOX_USER', 'PROXMOX_NODE', 'PROXMOX_API_TOKEN_ID'],
          network: ['DEFAULT_GATEWAY', 'DEFAULT_NAMESERVER', 'DEFAULT_NETWORK_CIDR', 'DEFAULT_DOMAIN'],
          services: ['NEXTCLOUD_IP', 'MAILSERVER_IP', 'KEYCLOAK_IP', 'NGINX_IP']
        };
        
        if (args.section === 'all' || args.section === 'status') {
          // Show configuration status
          output += '=== Configuration Status ===\n\n';
          
          const required = ['PROXMOX_HOST', 'PROXMOX_USER', 'DEFAULT_GATEWAY'];
          const missing = required.filter(key => !config[key]);
          
          if (missing.length === 0) {
            output += '✓ All required settings configured\n';
          } else {
            output += '✗ Missing required settings:\n';
            missing.forEach(key => {
              output += `  - ${key}\n`;
            });
          }
          
          output += '\n';
        }
        
        // Show requested sections
        const sectionsToShow = args.section === 'all' ? Object.keys(sections) : [args.section];
        
        sectionsToShow.forEach(section => {
          if (sections[section]) {
            output += `=== ${section.charAt(0).toUpperCase() + section.slice(1)} Configuration ===\n`;
            sections[section].forEach(key => {
              const value = config[key];
              if (value) {
                // Hide sensitive values
                const displayValue = key.includes('PASSWORD') || key.includes('SECRET') 
                  ? '***' 
                  : value;
                output += `${key}: ${displayValue}\n`;
              } else {
                output += `${key}: <not set>\n`;
              }
            });
            output += '\n';
          }
        });
        
        return {
          success: true,
          output: output.trim()
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to read configuration: ${error.message}`
        };
      }
    }
  },
  
  {
    name: 'test-connection',
    description: 'Test connection to configured services',
    inputSchema: TestConnectionSchema,
    handler: async (args) => {
      try {
        let output = '';
        
        switch (args.service) {
          case 'proxmox': {
            const host = process.env.PROXMOX_HOST;
            if (!host) {
              return {
                success: false,
                error: 'Proxmox host not configured. Run setup-proxmox first.'
              };
            }
            
            // Test HTTPS connection to Proxmox
            try {
              const { stdout } = await execAsync(`curl -k -s -o /dev/null -w "%{http_code}" https://${host}:8006/`);
              if (stdout === '200') {
                output = `✓ Successfully connected to Proxmox at ${host}:8006`;
              } else {
                output = `✗ Proxmox returned HTTP ${stdout}`;
              }
            } catch (error) {
              output = `✗ Failed to connect to Proxmox: ${error.message}`;
            }
            break;
          }
          
          case 'ssh': {
            // Test SSH to a sample host
            const testHost = process.env.PROXMOX_HOST || 'localhost';
            try {
              await execAsync(`ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no ${testHost} exit`, {
                timeout: 6000
              });
              output = `✓ SSH connection successful to ${testHost}`;
            } catch {
              output = `✗ SSH connection failed to ${testHost}`;
            }
            break;
          }
          
          case 'ansible': {
            // Test ansible connectivity
            try {
              const { stdout } = await execAsync('ansible --version');
              output = `✓ Ansible is installed and working\n${stdout}`;
            } catch {
              output = '✗ Ansible is not properly installed';
            }
            break;
          }
        }
        
        return {
          success: true,
          output
        };
      } catch (error) {
        return {
          success: false,
          error: `Connection test failed: ${error.message}`
        };
      }
    }
  },
  
  {
    name: 'setup-wizard',
    description: 'Run interactive setup wizard to configure all settings',
    inputSchema: z.object({}),
    handler: async () => {
      try {
        const output = `Welcome to MCP Server Setup Wizard!
=====================================

To configure your MCP server, I'll need some information about your environment.

Please run the following setup commands in order:

1. Configure Proxmox Connection:
   setup-proxmox with your Proxmox server details
   - host: Your Proxmox server IP
   - user: Usually "root@pam"
   - password or API token

2. Configure Network Settings:
   setup-network with your network configuration
   - gateway: Your network gateway (e.g., 192.168.1.1)
   - nameserver: DNS server (default: 8.8.8.8)
   - networkCidr: Network prefix (default: 24)

3. Configure Service IPs (optional):
   setup-services to assign IPs to services
   - nextcloudIp: IP for Nextcloud
   - mailserverIp: IP for Mail server
   - etc.

4. Test Your Configuration:
   test-connection proxmox to verify connectivity

Would you like me to guide you through each step?`;
        
        return {
          success: true,
          output
        };
      } catch (error) {
        return {
          success: false,
          error: `Setup wizard failed: ${error.message}`
        };
      }
    }
  }
];

// Create default .env if it doesn't exist
export async function ensureDefaultConfig() {
  const envPath = path.join(__dirname, '..', '.env');
  const envExamplePath = path.join(__dirname, '..', '.env.example');
  
  try {
    await fs.access(envPath);
  } catch {
    // .env doesn't exist, create from example or template
    try {
      await fs.copyFile(envExamplePath, envPath);
      console.error('Created .env from .env.example');
    } catch {
      // Create minimal .env
      const minimal = `# MCP Server Configuration
# Run 'setup-wizard' tool to configure

# Proxmox Configuration
PROXMOX_HOST=
PROXMOX_USER=root@pam
PROXMOX_PASSWORD=

# Network Configuration  
DEFAULT_GATEWAY=
DEFAULT_NAMESERVER=8.8.8.8
DEFAULT_NETWORK_CIDR=24

# SSE Server (if needed)
SSE_PORT=3001
API_ACCESS_TOKEN=default-token
`;
      await fs.writeFile(envPath, minimal);
      console.error('Created minimal .env file');
    }
  }
}